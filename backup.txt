func (s *TransactionService) CreateTransaction(ctx context.Context, req *v1.CreateTransactionRequest) (*v1.CreateTransactionReply, error) {
	conn, err := grpc.Dial("localhost:9013", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return nil, fmt.Errorf("failed to connect to account service: %w", err)
	}
	defer conn.Close()
	accountClient := accountpb.NewAccountClient(conn)

	// Fetch origin account
	originAcctResp, err := accountClient.GetAccountWithNum(ctx, &accountpb.AccountIdRequest{
		AccountNumber: req.OrginatoryAccount_Number,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch originator account: %w", err)
	}
	if len(originAcctResp.Accounts) == 0 {
		return nil, fmt.Errorf("originator account not found")
	}
	originAcct := originAcctResp.Accounts[0]

	
	if originAcct.AvailableBalance < req.Amount {
		return nil, fmt.Errorf("insufficient funds in originator account")
	}

	
	beneficiaryAcctResp, err := accountClient.GetAccountWithNum(ctx, &accountpb.AccountIdRequest{
		AccountNumber: req.BeneficiaryAccount_Number,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch beneficiary account: %w", err)
	}
	if len(beneficiaryAcctResp.Accounts) == 0 {
		return nil, fmt.Errorf("beneficiary account not found")
	}
	beneficiaryAcct := beneficiaryAcctResp.Accounts[0]

	// Update balances
	originNewBal := originAcct.AvailableBalance - req.Amount
	beneficiaryNewBal := beneficiaryAcct.AvailableBalance + req.Amount

	_, err = accountClient.UpdateAccount(ctx, &accountpb.UpdateRequest{
		AccountId:        originAcct.AccountId,
		CustomerId:       originAcct.CustomerId,
		AccountNumber:    originAcct.AccountNumber,
		AccountType:      originAcct.AccountType,
		Currency:         originAcct.Currency,
		Status:           originAcct.Status,
		AvailableBalance: originNewBal,
		PendingBalance:   originAcct.PendingBalance,
		CreditLimit:      originAcct.CreditLimit,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update origin account balance: %w", err)
	}
	_, err = accountClient.UpdateAccount(ctx, &accountpb.UpdateRequest{
		AccountId:        beneficiaryAcct.AccountId,
		CustomerId:       beneficiaryAcct.CustomerId,
		AccountNumber:    beneficiaryAcct.AccountNumber,
		AccountType:      beneficiaryAcct.AccountType,
		Currency:         beneficiaryAcct.Currency,
		Status:           beneficiaryAcct.Status,
		AvailableBalance: beneficiaryNewBal,
		PendingBalance:   beneficiaryAcct.PendingBalance,
		CreditLimit:      beneficiaryAcct.CreditLimit,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update beneficiary account balance: %w", err)
	}

	// Store transaction
	transaction := &biz.Transaction{
		TransactionId:             req.Transactionid,
		OrginatoryAccount_Number:  req.OrginatoryAccount_Number,
		BeneficiaryAccount_Number: req.BeneficiaryAccount_Number,
		TransactionType:           req.TransactionType,
		Amount:                    req.Amount,
		Currency:                  req.Currency,
		Status:                    req.Status,
		Description:               req.Description,
		ReferenceNumber:           req.ReferenceNumber,
		PostingDate:               req.PostingDate,
	}
	t, err := s.uc.CreateTransaction(ctx, transaction)
	if err != nil {
		return nil, fmt.Errorf("failed to record transaction: %w", err)
	}

	return &v1.CreateTransactionReply{
		Message:                   "Transaction processed: balances updated, transaction stored",
		TransactionId:             t.TransactionId,
		OrginatoryAccount_Number:  t.OrginatoryAccount_Number,
		BeneficiaryAccount_Number: t.BeneficiaryAccount_Number,
		TransactionType:           t.TransactionType,
		Amount:                    int64(t.Amount),
		Currency:                  t.Currency,
		Status:                    t.Status,
		Description:               t.Description,
		ReferenceNumber:           t.ReferenceNumber,
		PostingDate:               t.PostingDate,
	}, nil
}